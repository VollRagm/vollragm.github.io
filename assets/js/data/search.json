[
  
  {
    "title": "Abusing LargePageDrivers to copy shellcode into valid kernel modules",
    "url": "/posts/abusing-large-page-drivers/",
    "categories": "Kernel Development",
    "tags": "native, kernel, windows, reversing",
    "date": "2022-04-10 23:26:00 +0200",
    





    "snippet": "IntroductionMost people in the game hacking community write their kernel-mode drivers to get around kernel-level anti-cheats such as EasyAntiCheat.However, those anti-cheats have several methods to detect cheat drivers. The most commonly used way to load the cheat driver is manually mapping it with tools like kdmapper. Unfortunately, manually mapping a driver in this way causes the code to be outside of a valid module.Recommended communication methods like IOCTL are rendered unusable because they can be detected with a few lines of code.While reading through Windows Internals Part 1 and reverse engineering nt!KiSystemStartup I noticed a possible way to abuse a Windows feature to be able to copy shellcode into valid drivers typically read-only .data section and most importantly, execute it. This concept can potentially be used to prevent detection from game anti-cheats while communicating with kernel-mode.Checkout my lpmapper repository for the finished proof-of-concept.In this post, I’m going to demonstrate how to make use of this feature to have executable code in kernel-mode without having to allocate any memory.To understand this concept, we will have to take a short look into one of the core data structures of a processor: Page Tables.Large PagesWindows makes use of page tables to be able to create separate virtual memory spaces for each context.I will not go too much into detail about how they work as there are many posts about page tables out there already, such as this one. However, one important detail that oftentimes isn’t mentioned is the use of large pages.A common page table structure looks something like this:As you can see in this image, a Page Table (PT) can hold up to 512 Page Table Entries (PTEs). With each page having a size of 4096 bytes, this means a single page table can address 2 megabytes of physical memory. This is where large pages come into play. The 7th bit of PDPT-entries and PD-entries, which is called PageSize is used to determine, whether this page table entry points to another Page table or an entire physical page with the size the page table would map.For example, if the PageSize bit is set on a Page-directory entry (PDE), the page frame number of this entry points to a full contiguous physical 2 megabyte page instead of pointing to another page table. This also technically makes the PDE a PTE. The R/W and NX bits of the PTE decide whether the page is writable or executable. These properties apply to the entire page, which means that for normal pages, the smallest protection region you can modify is 4 kilobytes (4096 bytes). For a large page, it is 2 megabytes (512 * 4096 bytes) and for huge pages, it’s 1 gigabyte (512 * 512 * 4096 bytes).This aspect is going to become important later.Large pages are used in applications that need to allocate large memory regions and want to be able to access them quicker. Due to the missing step in the virtual to physical translation, the CPU can access large pages faster.  If you want to inspect the page tables on your system live to get a better understanding of page tables I recommend my tool PTView. By default, Windows maps the ntoskrnl.exe and hal.dll images on large pages. You can get their base address from a kernel debugger and enter it into PTView to directly get the large page they are on.LargePageDriversAs I mentioned Windows maps the ntoskrnl.exe image onto a large page. However, if we look into nt!MmLoadSystemImageEx which eventually gets called in the process of Phase 1 system initialization by nt!IoInitSystem, we will see a function named MiMapSystemImageWithLargePage being called after a check. As the name says, this function is responsible for mapping system drivers on large pages.MiUseLargeDriverPage takes the DriverName string and returns whether the driver should be loaded on a large page.I have reverse-engineered the function, the LIST_ENTRY struct, and renamed all variables accordingly.struct LARGE_PAGE_DRIVER_LIST_ENTRY {    LIST_ENTRY Flink;    LIST_ENTRY Blink;    UNICODE_STRING Name;}bool __stdcall MiUseLargeDriverPage(PCUNICODE_STRING DriverName){  LARGE_PAGE_DRIVER_LIST_ENTRY *LargePageDriversListEntry; // rbx  if ( (MiFlags &amp;amp; 0x8000) != 0 || (MiFlags &amp;amp; 0x10000) != 0 )    return 0;  if ( MapAllDriversIntoLargePages != 1 )  {      // Walk the list    for ( LargePageDriversListEntry = LargePargeDriversList;          LargePageDriversListEntry != &amp;amp;LargePargeDriversList;          LargePageDriversListEntry = LargePageDriversListEntry-&amp;gt;Flink )    {      if ( RtlEqualUnicodeString(DriverName, &amp;amp;LargePageDriversListEntry-&amp;gt;Name, 1u) )        return 1;    }    return 0;  }  return 1; // return true if MapAllDriversIntoLargePages is true}This means, to get a driver to load on a large page during boot we have to make sure it’s in the LargePargeDriversList. By listing all cross-references in IDA we can find out, that this list is being populated inside of nt!MiInitializeDriverImages which is eventually getting called from nt!MiInitSystem.The procedure references the global variable MmLargePageDriverBuffer from the ntoskrnl .INIT section. This variable contains the contents of the HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\LargePageDrivers value from the registry. This value has to be of type multi-string.It has to either contain the file names of the drivers separated by null-terminators or a *, which serves as a wildcard and is going to set the MapAllDriversIntoLargePages I have defined to true. The decompilation of the function shows how the value is being parsed.FirstLargePageDriverEntry = &amp;amp;LargePargeDriversList;LargePargeDriversList = &amp;amp;LargePargeDriversList;// Skip this part if there are no entriesif ( MmLargePageDriverBufferLength != -1 )    {StartOfBuffer = &amp;amp;MmLargePageDriverBuffer;EndOfBuffer = (&amp;amp;MmLargePageDriverBuffer + 2 * ((MmLargePageDriverBufferLength - 2) &amp;gt;&amp;gt; 1));if ( &amp;amp;MmLargePageDriverBuffer &amp;lt; EndOfBuffer ){    whitespaces = 0x100002601i64;    do    {    currentChar = *StartOfBuffer;    // check if current char is empty    if ( currentChar &amp;lt;= &#39; &#39;         &amp;amp;&amp;amp; _bittest64(&amp;amp;whitespaces, currentChar)         || currentChar == &quot;0\\0&quot; )       {        currentChar_1 = StartOfBuffer;    }    else    {        if ( currentChar == &#39;*&#39; ) // * for wildcard        {            MapAllDriversIntoLargePages = 1;            break;        }        for ( currentChar_1 = StartOfBuffer; currentChar_1 &amp;lt; EndOfBuffer; ++currentChar_1 )        {            currentCharValue = *currentChar_1;  // skip whitespaces            if ( currentCharValue &amp;lt;= &#39; &#39; &amp;amp;&amp;amp; _bittest64(&amp;amp;whitespaces, currentCharValue) )                break;                            if ( currentCharValue == &quot;0\\0&quot; )                break;        }        // allocate some memory for the new entry        NewLargePageDriverEntry = MiAllocatePool(0x40, &#39; &#39;, 0x704C6D4Du);        if ( !NewLargePageDriverEntry )            break;        //initialize entry        DriverNameLength = 2 * (currentChar_1 - StartOfBuffer);        NewLargePageDriverEntry-&amp;gt;Name.Buffer = StartOfBuffer;        NewLargePageDriverEntry-&amp;gt;Name.Length = DriverNameLength;        NewLargePageDriverEntry-&amp;gt;Name.MaximumLength = DriverNameLength;        OldEntry = FirstLargePageDriverEntry;        if ( *FirstLargePageDriverEntry != &amp;amp;LargePargeDriversList )            __fastfail(3u);        // Reassign the list links        NewLargePageDriverEntry-&amp;gt;Flink = &amp;amp;LargePargeDriversList;        *&amp;amp;NewLargePageDriverEntry-&amp;gt;Blink = OldEntry;        whitespaces = &quot;\\x01\\0\\0&amp;amp;\\x01&quot;;        *OldEntry = NewLargePageDriverEntry;        // set new list head        FirstLargePageDriverEntry = NewLargePageDriverEntry;    }    StartOfBuffer = currentChar_1 + 1;    }    while ( currentChar_1 + 1 &amp;lt; EndOfBuffer );}Now we reach the important part. Previously we learned that page protection applies to the entire page. Let’s say we load beep.sys onto a large page now. Its read-only .text section only has the size of a single page.Normally the image loader simply would map the .text section onto a single page and make it write-protected. The .data section also gets its own page, which then is going to be writable, but not executable.However, since the loader now is forced to place both the .text and .data sections onto the same page, those sections will be writable and executable.Note that this all is achieved without any page table manipulation and is a legitimate Windows feature.While modifying the normally read-only .text section still can easily be detected by comparing the image in memory with the file on the disk, we can freely modify the .data section and write our shellcode into it, which now can be executed.Finally, since the shellcode remains inside of the driver’s bounds I can directly point the driver’s Device-IO dispatch to the shellcode location inside of the .data section and call it from user-mode via DeviceIoControl.I will demonstrate this using the beep.sys driver, which is responsible for handling the Beep API function.Implementation  You can find the full implementation of this in the lpmapper repository. The lpmapper project will map the shellcode into beep.sys by default. This can be modified to use any other driver easily. If you want to test it, run the lpmapper-test project. Make sure that you added beep.sys to LargePageDrivers in the registry key mentioned above.Note that this concept can be abused in many different ways. For example, you could also just place the shellcode in a third-party driver and have it jump into your manually mapped driver.I however wanted to demonstrate a concept that does not require any memory allocation at all. The idea is to write a simple Device-IO dispatch handler, shrink it down to the essential part and only copy its the function’s instruction bytes into the .data section. Finally, I will assign the beep.sys driver dispatch to that shellcode.First of all, we have to make sure the HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\ registry key contains a multi-string value named LargePageDrivers. We are going to set it to either beep.sys, or * if you want to load all drivers onto large pages (which would be kind of wasteful).If we don’t do that, we are going to receive an ATTEMPTED_WRITE_TO_READONLY_MEMORY bluescreen, since lpmapper doesn’t check if the section is on a large page and is writable.I started by writing the dispatch handler in C++ since I have learned that compilers produce much better machine code than humans. The handler itself is very simple and supports 3 operations: reading cr3, getting a process main module base address, and arbitrarily reading/writing to process memory.NTSTATUS DeviceIOControlHandler(PDEVICE_OBJECT device, PIRP irp){    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);    auto inputBuffer = irpStack-&amp;gt;Parameters.DeviceIoControl.Type3InputBuffer;    auto outputBuffer = irp-&amp;gt;UserBuffer;    switch (irpStack-&amp;gt;Parameters.DeviceIoControl.IoControlCode)    {        case IOCTL_RDCR3:            if (outputBuffer)            {                *(uint64_t*)outputBuffer = __readcr3();             }            break;        case IOCTL_COPY:            if (inputBuffer)            {                memory_copy* data = (memory_copy*)inputBuffer;                PEPROCESS process = 0;                PsLookupProcessByProcessId(data-&amp;gt;processId, &amp;amp;process);                if (process)                {                    PEPROCESS sourceProcess = data-&amp;gt;write ? IoGetCurrentProcess() : process;                    PEPROCESS targetProcess = data-&amp;gt;write ? process : IoGetCurrentProcess();                    size_t dummy = 0;                    MmCopyVirtualMemory(source, data-&amp;gt;source, target, data-&amp;gt;target, data-&amp;gt;size, KernelMode, &amp;amp;dummy);                                        ObDereferenceObject(process);                }            }            break;        case IOCTL_PROCESS_BASE:            if (inputBuffer &amp;amp;&amp;amp; outputBuffer)            {                HANDLE processId = *(HANDLE*)inputBuffer;                PEPROCESS process = 0;                PsLookupProcessByProcessId(processId, &amp;amp;process);                if (process)                {                    auto base = PsGetProcessSectionBaseAddress(process);                    *(PVOID*)outputBuffer = base;                    ObDereferenceObject(process);                }            }            break;        default:            return OriginalDispatch(device, irp);    }    irp-&amp;gt;IoStatus.Information = 0;    irp-&amp;gt;IoStatus.Status = STATUS_SUCCESS;    IofCompleteRequest(irp, IO_NO_INCREMENT);    return STATUS_SUCCESS;}I wanted to keep this handler as simple as possible, which is why it doesn’t check for NTSTATUS results for example. This is up to you to implement.After writing the handler I used my ShellcodeBakery tool to get the shellcode from the compiled binary and display it as a C++ array ready to copy into a source file.However, the code calls a few imports. Usually, those imports are located inside of the IAT of the driver image. I won’t be mapping the entire driver image though, because I can only fit 4096 bytes into the beep.sys .data section and the driver image would be spread out across a few pages.This is why I made another tool, that builds a “custom” import address table at the end of the shellcode and relocates all import calls in the shellcode to their appropriate IAT entry.I did the same for the call to the OriginalDispatch. You can find that function table in the source code here. This table gets populated with the import address during runtime before its copied into kernel-mode.I used kdmapper’s intel_driver library to access kernel memory because it already had lots of useful functions implemented, such as GetKernelModuleExport.At first, lpmapper will try to find the beep.sys module and its DriverObject.I get the module address from GetKernelModuleExport, to get the DriverObject I created a new function in kdmapper called CallNtosExport. This function calls IoGetDeviceObjectPointer to get the Beep DeviceObject. The DeviceObject holds the DriverObject. This happens here.After that, I get the original driver dispatch from DriverObject-&amp;gt;MajorFunction[14]. This address is stored in the previously mentioned function table of the shellcode, along with all other needed imports which I can get using GetKernelModuleExport. The code responsible for this is located here.Finally, the shellcode is copied into the beep.sys .data section here.In the final step, lpmapper sets the DriverObjects Device-IO dispatch to the shellcode location here.TestingAfter running lpmapper you can now test the concept with the lpmapper-test project. This project also displays how to interact with the dispatch handler.The following code contains a reference to a handle to the Beep driver. You can acquire this handle using CreateFile:HANDLE beepHandle = CreateFile(L&quot;\\\\\\\\.\\\\GLOBALROOT\\\\Device\\\\Beep&quot;, FILE_ANY_ACCESS, 0,                                     nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);I’ll briefly go over how the 3 supported operations are implemented.Read CR3This operation is tested in TestReadCr3.It will return the value of the current CPUs cr3 register, which is the DirectoryTableBase of the current process, into the output buffer.const ULONG IOCTL_READCR3 = CTL_CODE(0x8000, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS);uint64_t cr3 = 0;bool success = DeviceIoControl(beepHandle, IOCTL_READCR3,    nullptr, 0,    &amp;amp;cr3, sizeof(uint64_t),    nullptr, nullptr);Getting a processes main module baseThis operation is tested in TestProcessBase.After passing in a process id into the input buffer it will return that process’s main module base address in the output buffer.const ULONG IOCTL_PROCESS_BASE = CTL_CODE(0x8000, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS);uint64_t processBase = 0;uint64_t processId = GetCurrentProcessId();bool success = DeviceIoControl(beepHandle, IOCTL_PROCESS_BASE,    &amp;amp;processId, sizeof(uint64_t),    &amp;amp;processBase, sizeof(uint64_t),    nullptr, nullptr);Reading and writing process memoryThis operation is tested in TestMemoryRead.You have to initialize a memory_copy struct which has to be passed to the input buffer.The processId member of that struct holds the target process. The write member decides whether the procedure reads from the target process, or writes to it. sourceAddress and targetAddress have to be set accordingly. The size member determines the number of bytes to copy.struct memory_copy{    uint64_t processId;    PVOID sourceAddress;    PVOID targetAddress;    BOOL write;    SIZE_T size;};const ULONG IOCTL_COPY = CTL_CODE(0x8000, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS);char buffer[3]; // buffer for &quot;MZ&quot; + &#39;\\0&#39;memory_copy data = {};data.processId = GetCurrentProcessId();data.targetAddress = buffer;data.sourceAddress = (PVOID)baseAddress;data.write = false;data.size = 2; //only read MZ into bufferbuffer[2] = 0; // set null terminator after &quot;MZ&quot;bool success = DeviceIoControl(beepHandle, IOCTL_COPY,    &amp;amp;data, sizeof(memory_copy),    nullptr, 0,    nullptr, nullptr);DetectionI have tested this on an EasyAntiCheat protected game for a substantial amount of time and did not run into a ban, but that is not enough data, since EasyAntiCheat is known for not always banning a player when it detects something.Since LargePageDrivers is an in-house Windows feature, the best the anti-cheat can do is to give you a little flag for having a driver mapped in such a way.I’m going to discuss the possible ways how this could potentially be detected - and what can be done to prevent that from happening.If you noticed any detection vector that I missed feel free to contact me on Discord or Twitter about it.Dispatch HooksIn my example, I hooked the driver’s dispatch. You might be wondering why I can’t just point that to my driver residing inside of a pool.This simply is, because most modern anti-cheats simply check if the dispatch function is located within the driver’s bounds.Such a check could look something like this:PDRIVER_OBJECT diskDriver = //get the DriverObject PVOID driverDispatch = diskDriver-&amp;gt;MajorFunction[IRP_MJ_DEVICE_CONTROL]; if(driverDispatch &amp;gt; diskDriver.DriverStart + diskDriver.DriverSize ||   driverDispatch &amp;lt; diskDriver.DriverStart){    // Take action}The most common anti-cheats have been doing this for ages.The EAC-Reversing repository  showcases how EasyAntiCheat was doing it back in 2019 at least.For BattlEye I have analyzed the recently released full bedaisy.sys dump posted on unknowncheats.me by anypot.I have found a few of those checks, this could be a self-integrity check, however, the principle is the same:for ( majorFunctionIndex = 0; majorFunctionIndex &amp;lt; 0x1C; ++majorFunctionIndex ){    majorFunction = DriverObject-&amp;gt;MajorFunction[majorFunctionIndex];    if ( majorFunction )    {        DriverStart = DriverObject-&amp;gt;DriverStart;        if ( majorFunction &amp;lt; DriverStart || majorFunction &amp;gt;= DriverStart + DriverObject-&amp;gt;DriverSize )        {            // take action        }    }}If you take a look at those, you will notice that this PoC passes those checks, since the dispatch still points to an address inside of the driver’s bounds.A way to detect this project specifically would be to parse the Debug symbols for beep.sys and check, if the dispatch is pointing to the correct dispatch handler.However, you can easily modify this project to use any third-party driver that does not have symbols available.Another way to at least flag this, is to check whether the dispatch is pointing into an executable section using the PE header. The problem with that once again is, that it is technically not illegal to have the dispatch pointing into the .data section. It’s not common, but a reputable anti-cheat should be careful in taking action due to such flags. If you use techniques to obfuscate and encrypt the shellcode it could potentially make it even harder to detect reliably.Stack walkingStack walking is an often-discussed detection method used by anti-cheats. It works by delivering APCs to all threads, getting their contexts, and checking the return addresses on the stack. Those are then used to determine whether the thread has been executing code outside of a valid module.However, in my example, the thread never leaves the beep.sys or ntoskrnl.exe module.ConclusionIt has been a pleasure researching this feature. I highly recommend you to read through Windows Internals Part 1 as it is a good book and can spark a few ideas.If you found a mistake in this post or noticed a critical fact that I missed, please contact me over Discord, Twitter, or any channel you find. I highly appreciate any critical feedback I can get."
  },
  
  {
    "title": "Showing a MessageBox from kernel-mode",
    "url": "/posts/kernel-message-box/",
    "categories": "Kernel Development",
    "tags": "native, kernel, windows, reversing",
    "date": "2022-04-05 14:44:00 +0200",
    





    "snippet": "IntroductionMessage boxes provide a simple way to show feedback to the user. In user-mode, a message box can be shown with the MessageBoxW API function. However, this API does not exist in kernel-mode. One of the common ways to display info from kernel-mode is the DbgPrint API, which can be listened to from DbgView or an attached Kernel debugger. Recently I wanted to display a message box from kernel-mode though, so the user can receive feedback easily. There already are sources on how it’s done out on the web, but I want to take you through the inner workings of the MessageBox function itself and add more information to it.  This entire procedure only works if the calling thread belongs to a user-mode process. This means it works when manually mapping a driver with a mapper like kdmapper. The reason for this limitation will be explained later.MessageBoxWThe MessageBoxW API is located inside of user32.dll. The only thing it does is to call MessageBoxTimeoutW. Inside of MessageBoxTimeoutW, a struct is initialized which holds all arguments for the message box, such as the text, caption, and type. Finally, MessageBoxWorker gets called. This function runs some extra checks, for example, if the current thread is a GUI thread. It also checks whether a parent window handle was passed into MessageBoxW. If that is the case, the function calls into SoftModalMessageBox, otherwise, it calls ServiceMessageBox. Since we don’t have a parent window handle in kernel-mode, we are going to enter ServiceMessageBox.This is where interesting things happen. After checking the threads and processes session IDs it puts the message box arguments into an array and calls the NtRaiseHardError API from ntdll.dll. The ErrorStatus argument is set to 0x50000018, which is STATUS_SERVICE_NOTIFICATION.RtlInitUnicodeString(&amp;amp;lpTextStr, lpText);RtlInitUnicodeString(&amp;amp;lpCaptionStr, lpCaption);arguments[2] = MsgBoxType2;arguments[0] = &amp;amp;lpTextStr;arguments[3] = v4;arguments[1] = &amp;amp;lpCaptionStr;if ( NtRaiseHardError(0x50000018, 4, 3, arguments, 1, &amp;amp;response) &amp;lt; 0 || (v20 = response, response &amp;gt;= 0xB) )    v20 = 1i64;ImplementationWe can reproduce this behavior easily. The kernel-mode API for NtRaiseHardError is the ntoskrnl export ExRaiseHardError.The Response argument even returns the message boxes response, for example, which button the user clicked on a Yes/No prompt. The types match the one from user-mode (e.g. MB_OK, MB_YESNO).As I mentioned above, the calling thread must belong to a user-mode thread. If you use the Service Manager to start your driver and call this in your DriverEntry it will not work. However, if you call it in your IOCTL handler it is going to work because the thread originated from a DeviceIoControl call in a user-mode process. The reason for this limitation is, that ExRaiseHardError in kernel-mode eventually does a Local Procedure Call to the exception port of the executing process. The System process does not have that.Furthermore, the first bit in PEPROCESS-&amp;gt;DefaultHardErrorProcessing has to be set accordingly. I have tried attaching to another process using KeStackAttachProcess, this caused a MessageBox to show up, but it was empty and at this point, I stopped going further.For the people manually mapping their drivers however and wanting simple feedback for a potential user, here is the implementation:extern &quot;C&quot; NTSTATUS NTAPI ExRaiseHardError(    NTSTATUS ErrorStatus, ULONG NumberOfParameters,     ULONG UnicodeStringParameterMask, PULONG_PTR Parameters,    ULONG ValidResponseOptions, PULONG Response);ULONG KeMessageBox(PCWSTR title, PCWSTR text, ULONG_PTR type){    UNICODE_STRING uTitle = { 0 };    UNICODE_STRING uText = { 0 };    RtlInitUnicodeString(&amp;amp;uTitle, title);    RtlInitUnicodeString(&amp;amp;uText, text);    ULONG_PTR args[] = { (ULONG_PTR)&amp;amp;uText, (ULONG_PTR)&amp;amp;uTitle, type };    ULONG response = 0;    ExRaiseHardError(STATUS_SERVICE_NOTIFICATION, 3, 3, args, 2, &amp;amp;response);    return response;}Usage example:#define MB_OK 0x00000000LULONG result = KeMessageBox(L&quot;Hello world!&quot;, L&quot;Greetings from kernel-mode&quot;, MB_OK);This is the enum containing all possible results:typedef enum _HARDERROR_RESPONSE{    ResponseReturnToCaller,    ResponseNotHandled,    ResponseAbort,    ResponseCancel,    ResponseIgnore,    ResponseNo,    ResponseOk,    ResponseRetry,    ResponseYes,    ResponseTryAgain,    ResponseContinue} HARDERROR_RESPONSE;"
  },
  
  {
    "title": "PTView - Browse Page Tables on Windows",
    "url": "/posts/ptview/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel",
    "date": "2022-04-04 23:58:00 +0200",
    





    "snippet": "IntroductionPage Tables can be a complicated concept to understand.This is why I created PTView. You can use this tool to visualize page tables and be able to browse them.It allows you to inspect a Windows processes Page Tables live.You can browse through them in a GUI and dump the physical pages they point to, as well as translate virtual to physical addresses and get the virtual address to a PTE.You can get the newest prebuilt release here.UsageYou will have to load the driver before running the client.I recommend loading the Driver normally in test mode, but it can be mapped as well, just make sure the first argument is the driver base and the second argument is NULL.After opening the client, select a process and start browsing its page tables!Key features  Browse Page Tables of Processes, including system processes  Highlight different types of Pages  Dump a physical page  Get the virtual address that leads to the current selection  Translate a physical address to a virtual address with visualization  Get information on a Page table entry  Support for Large PagesThings worth trying out1. Dump the PML4 itself over its auto-entry (self-reference):Every PML4 keeps an entry that has the PML4’s address as PFN itself. This entry is at a fixed index, that Windows nowadays sets randomly during boot.If this entry is selected, the PDPT is the PML4 itself again. If you select it in the PDPT again, the PD also is the PML4 again. If you continue that until the end, the PT will be the PML4, and you will be able to use the PML4 auto-entry to dump the PML4 itself or get its virtual address.Note that this address only is valid in the selected processes context.2. Watch Windows Memory manager map pages, that have been paged out to disk:Get the virtual address of an unused loaded module in the process. Enter it in the Virtual Address textbox and translate it.Chances are that the PTE of that VA or the subsequent PTE’s PFNs is 0x0.Now access the virtual address using a Debugger or Memory viewer, like Cheat Engine, and you will see how it raises a page fault, causing Windows Memory Manager to map the pages live."
  },
  
  {
    "title": "KernelSharp - Write Kernel Drivers in C#",
    "url": "/posts/kernelsharp/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel, .net",
    "date": "2022-04-04 23:56:00 +0200",
    





    "snippet": "IntroductionIn the past, people asked me if it was possible to write a kernel-mode Driver for Windows in C#.Now, you might be thinking that something like this would be totally foolish and serve no purpose.Let me tell you one thing: You are totally right about that.But after getting asked this question multiple times, I have decided to make it possible..NET in Kernel-mode?There are several reasons, why the .NET Runtime is not really able to run in kernel-mode, in fact, there are too many to list them all.The biggest reason, besides its memory management, is the Just-in-time compiler. The runtime compiles the code from MSIL to native code while the program runs. There are a lot of ways in which this could go wrong in kernel mode. As an example, you would never be able to make an HVCI-compatible driver because the native code would have to be written to the heap.However, this is where NativeAOT comes into play.NativeAOTNativeAOT is an experimental fork of the .NET Runtime. At the time of writing it is planned to be moved into mainline development in .NET 7. NativeAOT allows us to compile our C# programs to a native binary ahead of time.It works by taking the intermediate code, transpiling it to native code, and outputting an object file, which can be linked afterward. This compiler is included in the Microsoft.DotNet.ILCompiler package.Follow the NativeAOT quick start guide if you want to create your own project.Developing a DriverIf you want to follow along, feel free to clone the KernelSharp repository, because it basically is ready to compile already.Since we will be going down into kernel mode, we cannot have .NET libraries with us. Simple classes like System.String already require dynamic memory allocation and other routines that are not available in kernel mode in the same way.This is why we have to strip all standard libraries with &amp;lt;NoStdLib&amp;gt;true&amp;lt;/NoStdLib&amp;gt; in the .csproj file. In order to still have the basic datatypes with their basic functionality, we have to define them ourselves. Thankfully this part has been done by Michal Strehovsky for EFI boot applications already. I also recommend enabling unsafe code, because at some point we will be forced to work with pointers.With all of that setup, we can write a simple driver.static uint DriverEntry(){    return 0x0; //STATUS_SUCCESS}However, currently, there is no way to call any kernel-mode API. This part is crucial, otherwise, we would be pretty limited.Normally we would use the DllImport attribute to import native functions from other modules into our C# code, however, that is not available here. We have to use the RuntimeImport attribute, which we once again have to implement it first since all standard libraries have been stripped.After implementing the MethodImpl attribute as well, we can now import functions from ntoskrnl.[MethodImpl(MethodImplOptions.InternalCall)][RuntimeImport(&quot;ntoskrnl.exe&quot;, &quot;ExAllocatePool&quot;)]public static extern PVOID ExAllocatePool(PoolType poolType, ulong size);The code above is from my libraries WDK class. I have imported a lot of useful ntoskrnl functions there and defined some datatypes like PVOID and PEPROCESS.I even implemented __readcr3 using a dirty workaround since the compiler does not support intrinsics yet.public static ulong __readcr3(){    void* buffer = stackalloc byte[0x5C0];    var sat = KeSaveStateForHibernate(buffer); // saves CPU context into buffer    ulong cr3 = *(ulong*)((ulong)buffer + 0x10);    return cr3;}Compiling the DriverThe build script in my repository basically only does 3 simple things:  Compile all C# classes to MSIL  Compile MSIL binary to a native object file using the experimental compiler  Link the object file together with ntoskrnl.lib to a .sys fileLimitationsWhile creating this project, I have come across a few limitations.  No support for variadic argumentsBy default, C# already only supports passing variadic arguments to native functions using the undocumented __arglist. In this case, it seems not to be possible at all, which can make calling functions like DbgPrint a bit annoying, since you can only pass a fixed amount of arguments.  Strings always get stored as Wide-strings by the compilerThis is annoying when you need to pass a normal char* to a function. In those cases you have to convert the string to a char* first.However, Michal Strehovsky pointed out that there is a String Literal Generator for UTF-8 strings on Twitter DMs.  Global strings misplacedI am not entirely sure if this was not an edge case, but when referencing a globally defined string in my code the driver would bugcheck, because the compiler somehow did not place the string at the correct place in memory. I haven’t debugged this any further though and it works when writing the strings inside of the method bodies.ConclusionThis is a very experimental project and I don’t recommend doing this.The only purpose of this project is to prove that kernel drivers are possible in C# and that C# native compilation is around the corner.If you want to see an example of this library being used, check out my KernelBypassSharp repository."
  },
  
  {
    "title": "Unity Engine reversing and hacking",
    "url": "/posts/unity-reversing/",
    "categories": "Reverse Engineering",
    "tags": ".net, reversing, game hacking",
    "date": "2022-04-04 23:41:00 +0200",
    





    "snippet": "IntroductionUnity3D is a popular game engine used by many games, like Escape from Tarkov, Rust, Fall Guys, Among Us, and many more. The engine uses C# as scripting backend, and by default runs on top of the Mono Runtime. Since C# assemblies get compiled to MSIL, we can easily reverse engineer them using tools like dnSpy.We are also able to easily inject our dependencies and even reference the games and the engine’s dependencies in our source code. In Unity, this generally is used for writing mods, such as for the game Beat Saber, which depends on the modding community.In this post I will be using the simple game Adventure Communist, which is for free on steam.  Show screenshot of the game      This game is not protected by Il2Cpp. Games like Fall Guys and Among Us are. However, you can achieve the same results by using tools like Il2CppDumper and Il2CppAssemblyUnhollower.Decompiling the game’s codeAll (non-il2cpp) Unity games have an Assembly-CSharp.dll located inside of GameRoot\\TheNameOfTheGame_Data\\Managed\\. This file contains all game scripts. We need to plug this DLL into a .NET decompiler. I recommend dnSpy because it is very powerful.Finding a starting pointThis game is a clicker game and its goal is to gain as many resources as possible. Let’s try to increase the number of potatoes.Obviously, one could simply edit the save files, however, that would be very boring.I started by using the search tool in dnSpy to search for Potato. The search tool can be found in the top bar, right next to the Start button. The search yielded a single result.It’s an Enum with all types of resources that can be gathered in the game.Now, if you have some experience with IDA, the next thing you would do here is to look for cross-references. We are going to do the same thing here.Going down the rabbit holeLet’s see what references that Enum. We have to find the class that contains all values we need.We can list cross-references in dnSpy by right-clicking the Enums name and then clicking Analyze. A list is going to show up listing all types of usages of the Enum. I noticed that the Enum was being used in a class called GeneratorData.The game has different types of “Generators” which generate items while you aren’t clicking. Now we do the same trick on the GeneratorData class: right-click -&amp;gt; Analyze.dnSpy will show us, that a GeneretorData object is being used to initialize an object of type GeneratorModel inside of the Execute method in the InitializeGameModelCommand class.This method seems to be initializing Generators for all kinds of resources.An object of type GameModel is passed into this method which contains a Dictionary called Resources. This is the Dictionary that stores the number of resources we have.This means that we have to get this GameModel instance somehow. However, before that, we are going to take a quick dive into the engine’s principles.What is a GameObject?We know that we have to find the GameModel instance. To do so, we have to understand the engine’s structure first.Every scene holds GameObjects. GameObjects do nothing by default. However, we can apply components to a GameObject, such as a C# script.All C# script classes have to inherit from the MonoBehaviour class.After doing so, you can place methods like Start() or Update() in your code and the engine will call them for you at initialization or on each frame.This means that we can assume, that the game has a GameObject somewhere which has a script component managing the game. This script class likely holds the GameModel instance we are searching for.Finding the game managerWe know, that the GameModel is getting initialized by that Execute method. This method call can once again be traced using dnSpy’s Analyze feature.The method is getting called from GameController.Init().This GameController class however still does not inherit MonoBehaviour, which means that it is not a component of a GameObject.We need to repeat the analysis on the GameController class to see, where it’s being initialized.We end up in SceneRootGame.Start().SceneRootGame does inherit from MonoBehaviour and it also has the Start() method, which will get called by the engine when the GameObject spawns.It also holds a reference to the GameController, which holds the reference to the GameModel. Finally, the GameModel has the dictionary with all resource counts.Developing a hack trainerThe gained knowledge can be used to write a DLL dependency that can be injected into the game. For this, you are going to need to set up a C# class library, reference the game’s DLLs, and set up a loader. If you haven’t done this before I highly recommend you to check out Zat’s Beginner’s Guide To Hacking Unity Games because the entire set up procedure is explained there.Anyways, the final step is getting the SceneRootGame instance itself. Since it is a GameObject component, we can use the engine method GameObject.FindObjectOfType&amp;lt;Type&amp;gt;() to search for the instance.If we pass in SceneRootGame as the type, we will get the first SceneRootGame instance it finds. Once again, this then contains the GameModel, et cetera.The following code is going to give us a lot of potatoes.using AdComm; //import game namespaceusing System;using System.Collections.Generic;using System.Linq;using UnityEngine;  //import unity engine namespace public class ItemsCheat{    public void CheatPotatoes()    {        SceneRootGame sceneRoot = GameObject.FindObjectOfType&amp;lt;SceneRootGame&amp;gt;(); //get the SceneRootGame object that controls everything        GameController gameController = sceneRoot.Game; //get the GameController of the SceneRootGame        GameModel gameModel = gameController.Model; //get the game model         gameModel.Resources[ AdComm.Resources.Resource.Potato ].Value = 10000000;   //set the value of the Potato Resource to a high number    }}We can iterate over the resources Enum and set all types of resources to a high value as well.public void GetAllItems(){    SceneRootGame sceneRoot = GameObject.FindObjectOfType&amp;lt;SceneRootGame&amp;gt;(); //get the SceneRootGame object that controls everything    GameController gameController = sceneRoot.Game; //get the GameController of the SceneRootGame    GameModel gameModel = gameController.Model; //get the game model    List&amp;lt;AdComm.Resources.Resource&amp;gt; AllResources = Enum.GetValues(                                                    typeof(AdComm.Resources.Resource))                                                    .Cast&amp;lt;AdComm.Resources.Resource&amp;gt;().ToList();  //get all available Resource Types as list    foreach (AdComm.Resources.Resource resourceType in AllResources) //iterate through the resources    {        gameModel.Resources[resourceType].Value = 1000000000; //set amount of the resource to huge number    }}ConclusionUnity game hacking is a lot of fun. There is a lot that can be done thanks to the direct access to engine methods.You can easily spawn new GameObjects, modify textures, and do a lot of other things. It gets slightly harder when the game is protected with Il2cpp, but not impossible. Sadly many multiplayer games use advanced anti-cheats like EasyAntiCheat, and due to the nature of Mono injection, it is hard to inject a Mono DLL without getting caught by the anti-cheat. In those cases, it’s probably better to go for a native approach."
  },
  
  {
    "title": "Reverse engineering a Web API",
    "url": "/posts/web-api/",
    "categories": "Reverse Engineering",
    "tags": "reversing",
    "date": "2022-04-04 22:34:00 +0200",
    





    "snippet": "IntroductionMost websites or web services have an API in the backend that delivers requested data to its frontend. This can be anything from the Google Search API to delivering a message on Discord.Some people in the gaming community scan a game’s username database for certain available special names, like 3 letter names, to register them. I’ve been asked to write a tool to automate that. To do that I had to reverse engineer the R6DB API. I then could use that API to check for available usernames programmatically.This API has shut down since, likely due to abuse.The method I’m going to show also works on Electron Apps such as Discord by bringing up the DevTools. For any other app, you can use something like Fiddler to intercept the web requests.Finding the correct endpointFirst of all, we will have to find the right endpoint we need to talk to. An endpoint just is a point in a Web API that allows the client to request a specific resource from the server.The website has a textbox which names are typed into. This triggers the browser to send a request to their API. We can simply intercept them by opening the DevTools using Ctrl + Shift + I and then going to the Network tab.You can clear all requests in this window by clicking the clear button next to the red one in the top bar.As you can see, when I typed in a name, Chrome put the requests that were sent to the server into this list. We can now view a request’s information simply by selecting it.The first tab contains the request headers. Those headers provide the information about the request to the server. Stuff like Cookies, Auth Tokens, Cloudflare IDs, and expected response types (JSON, XML, …) get sent here.The URL I have underlined in red is the address this request has been sent to, which also is our target endpoint.As you can see, the syntax seems to be pretty simple: https://api.statsdb.net/r6/namecheck/&amp;lt;username&amp;gt;We can check the response format by clicking on the “Response” tab.The API returns a JSON object. The value “exists” specifies is an account is existent or not.Now that we know the endpoint that receives the requests we can move on to the next step.What else do I need to give the server?Next, you would need to check if the server expects any data from you. As you can see in the header tab, the request type is GET. A GET request does not send any form-data along with it. If it was a POST request, there probably would be data attached to the request in a format like application/form-data or application/json. You can look those up here.So, that means we should be good to go? Let’s try it! I’m gonna try to send a request in an App called Postman which can be used to build custom Web requests and to test Web APIs.I entered the correct URL, selected GET as the request method and the server declined my request and told me I was “Unauthorized”.Let’s take a deeper look into the request that got sent by Chrome…Most of those headers are normal and “don’t really matter”. The only one that immediately gained my attention was the x-api-key. Seems like the Webserver checks if the request was sent from a “real user” using this API Key.  Some APIs also might check if the user-agent is valid.Let’s just try copying out this API key and putting it into our Postman request.Now that I have provided the server with a valid API key it gave me the response I wanted. There is one issue though: This API key I copied keeps changing on each refresh and it also becomes invalid after some time. So, I will have to find a way to generate it myself.  In the image I also added the “origin” header. This was needed for this API to work. I figured this out by adding all headers and then removing them one by one until it stopped working, to see which ones are required.Generating the API-KeyOne thing that’s for sure is that the API Key is getting generated before the request is sent. One way to find out how the API works internally is by clicking on the executing script for the request on the network window and then placing a breakpoint there to check out what the JS code is doing. This can get painful though, especially when the code is obfuscated.I decided to just refresh the page and check out all other requests that we’re made to see if I find the one that contained the API key.I noticed this request to the authscript endpoint. It was a simple GET request and it returned the following plaintext:This is JavaScript code. The eval function executes the function with the parameters that are underlined in red at the bottom. The string at the bottom looks like something that is encrypted in some way and the function decrypts it. I defined both of those functions in the JS Console and then executed them with the provided parameters.The return value surprised me:It returned another JavaScript function as a string. It is called “generateAuthToken”, which looks very promising. It takes a timestamp as input, which I assumed is a simple Unix timestamp.This is what the function looks like after beautifying it:function generateAuthToken(timestamp) {    if (timestamp === undefined) return false;    let seed = &quot;2ef60f0ab98606ec365ac16da6d1e00e3129a5d5&quot;;    let sTimestamp = timestamp + &quot;&quot;;    let code = &quot;&quot;;    for (let i = 0; i &amp;lt; sTimestamp.length; i++) {        let t = parseInt(sTimestamp.charAt(i));        let c = seed.charCodeAt(i % seed.length);        switch (t) {            case 0:                break;            case 1:                c = c - 1;                break;            case 2:                c = c &amp;gt;&amp;gt; 1;                break;            case 3:                c = c &amp;lt;&amp;lt; 1;                break;            case 4:                c = Math.pow(t, c % 4);                break;            case 5:                c = Math.round(Math.sqrt(c));                break;            case 6:                c = c &amp;lt;&amp;lt; t;            case 7:                c = c - 12;                break;            case 8:                c = 0;                break;            default:                c = false;                break;        }        if (c === false) continue;        code += c;    }    return btoa(&quot;authscript:&quot; + code + &quot;:&quot; + timestamp + &quot;:1617148800&quot;);};window.dispatchEvent(new Event(&#39;authscript&#39;));I defined it and called it with the current Unix timestamp.This return value I got looks very much like the API Key that was previously generated by the site itself.I plugged my custom generated API-Key into Postman - et voila!Now we can move on to the next step and use the API in our code.Sending requests to the API programmaticallyI decided to go with C# for my implementation because it has an easy-to-use HttpClient and it’s the language I use the most.If you look into the generateAuthToken function above you will notice that there is this seed that is taken into consideration when decoding the string. A day has passed and I noticed, that this seed changes. That means, that I need to request the source code of the function every time because I cannot hardcode this seed.Luckily, there is a popular library for C# called jint. It’s a basic and relatively lightweight JavaScript interpreter. I simply requested the JS Code from the authscript endpoint and passed it into the JS Engine.Then I passed in the decoded function into it again after some formatting and I could execute it from C# Code.private JsValue ParseAuthTokenGenerator(string encoded, int unknown0, string key, int unknown1, int unknown2, int unknown3){    Engine engine = new Engine();    //those 2 shouldn&#39;t change    engine.Execute(JSCode.CharDecrypter);    engine.Execute(JSCode.StringDecoder);    var jsCode = engine.Invoke(&quot;decodeFunction&quot;, encoded, unknown0, key, unknown1, unknown2, unknown3).AsString()                                                                                .Replace(JSCode.UselessBSCode, &quot;&quot;)                                                                                .Replace(&quot;btoa&quot;, &quot;&quot;) + &quot;}&quot;; // jint has no btoa support    engine.Execute(jsCode);    //return callable generateAuthToken function     return engine.GetValue(&quot;generateAuthToken&quot;);}Both functions that decode the third one don’t change, so I hardcoded them. After decoding generateAuthToken I can simply invoke it and make my request to the API:var apiKey = await GenerateAuthToken();var request = new HttpRequestMessage(HttpMethod.Get, &quot;https://api.statsdb.net/r6/namecheck/&quot; + name);request.Headers.Add(&quot;x-api-key&quot;, APIKey);request.Headers.Add(&quot;origin&quot;, &quot;https://r6db.net&quot;);var response = await httpClient.SendAsync(request);var str = await response.Content.ReadAsStringAsync();ConclusionWhen I was asked to do that, I did not know what exactly this was for. I released this project publicly and based on the number of messages I got after this stopped working, quite a few people were using it.This entire API Key was to prevent spam. One of this websites authors even replied to my original post:  I’m one of the Owners of StatsDB and really cool project you have here but I wanna point something out. We do have a public/developer api and you can get your own key just by signing in and creating a application. No need to reverse enginire our token system it will just work.If a service has a public API available, please use that. However, if there isn’t such a public API or you need to get around an API quota or limit you can always reverse the private API."
  },
  
  {
    "title": "Reverse engineering Windows 7 Minesweeper",
    "url": "/posts/minesweeper/",
    "categories": "Reverse Engineering",
    "tags": "native, windows, reversing, game hacking",
    "date": "2022-04-04 22:23:00 +0200",
    





    "snippet": "IntroductionThis blog post is about how to approach reverse engineering using the Windows 7 version of Minesweeper as an example. You can get the Windows 7 Minesweeper from https://win7games.com/.I have created a trainer and a CheatEngine cheat table as well. You can find it here.This post is written for beginners, however, I recommend having the following already:  Basic understanding of Pointers  Basic understanding of the C/C++ language  Good understanding of Cheat Engine  A little bit of ASM knowledge  Native Decompiler (IDA, Ghidra, …)  PatienceFinding a starting pointWhenever you want to reverse engineer something, you need a starting point. This could be anything from an interesting instruction to a global variable. CheatEngine is a tool that is very helpful to find such variables. For example, in a First-person-shooter game, I would start scanning for values like the health or bullet count, however, in Minesweeper I decided to scan for the timer value.The timer value is on the bottom leftAs you can see the Timer value is 6 in this image. So I started to scan for a 4-byte value.I did not get a single result. Then I tried a different datatype: float.The right address popped up in the first scan. When I changed it, the timer in the game changed as well, so I know it was the right one.Now we have found the value of the timer.Tinkering around with the TimerOf course, we can now set the timer value to anything we want. But what else can we do? By right-clicking the address in Cheat Engine and then clicking Find out what writes to this address we can determine the instruction, that is writing to the address.We can select the instruction and show it in the disassembler. This takes us directly to the part in the code responsible for updating the timer.We can see that the instruction adding to the timer value is addss xmm0,[7FF7812E4454] , which means if we patch that to subss xmm0,[7FF7812E4454] (add stands for add, sub stands for subtract), then we will see the timer running backward.Finding more valuesIn the instruction from the previous headline we could see that the address of the timer value is at rax + 0x20. We can assume that rax is a pointer to some kind of structure containing other useful variables. To check that we right-click the address and hit Browse this memory region in CheatEngine. Now the bottom part of the memory viewer will show the neighboring addresses. Click inside that window and hit Ctrl + 6 to change the datatype to 4 bytes. Scroll up a bit to be able to see the values that come right before the timer.The value highlighted in red is the timer value.It’s being displayed wrongly because we set the datatype to 4 bytes instead of float. However, it is surrounded by other values. Now you need to look at which addresses change when you do something. I’ve already done that.The first address, which is at offset 0x8 from the beginning of the structure is the number of bombs. It is followed by FieldSizeY, FieldSizeX. The next 0 is the number of flags, the 6 is the number of revealed fields, and the 1 is how many times you have clicked. The 1 right next to the timer is the difficulty level.To find a Pointer for that struct, you can run a pointer scan or manually reverse it. I manually reversed it: Minesweeper.exe+ 0xAAA38 ] + 0x18 ].If you dereference this pointer and add 0x20 to it, you will get the address of the timer (think of the rax + 0x20 from earlier).Finding the bomb arrayI figured out that a good approach to finding the bomb array is to find the function that is called whenever I click a field.Do you remember the value that counts how many times you click?This pointer points to it: Minesweeper.exe+ 0xAAA38 ] + 0x18 ] + 0x1C.It must be associated with the function we are searching for in some way, so let’s do the trick again: right-click the address -&amp;gt; Find out what writes to this address. Now you need to click a field in Minesweeper. You will see an instruction popping up in CheatEngine: inc [rbx+1C]. This instruction increases [rbx + 0x1C] by one. RBX contains the address of that same structure from earlier again here. I will be calling it GameManager from now on.Now, this is where our Decompiler comes into play. I’m going to use IDA.Load Minesweeper.exe into the decompiler, let the analysis finish, and rebase the image. In IDA you can do this by going to Edit -&amp;gt; Segments -&amp;gt; Rebase program. Enter the module base address of Minesweeper in there, which you can get from CheatEngine.After that is done, jump to the instruction address that increased the click count in IDA.In IDA you can hit F5 to decompile it to pseudo-C-code.I recommend converting the pointer offsets from decimal to hexadecimal by clicking them and hitting H on the keyboard.First of all, the ++v6[7] in line 22 is the instruction that increased the counter.Now I analyzed the parameters that have been passed into the function by setting a breakpoint at the start of the function in CheatEngine. I clicked another field to trigger the breakpoint.The first parameter is the GameManager from earlier, the second parameter was the X coordinate I clicked, and the third one is the Y coordinate. I renamed them accordingly in IDA.Now I saw those two big if statements, both using the X and Y variable. After looking up, what their values are, I found out, that they are two different data structures. One of them contains the state of the field (for example if it has been revealed already), and the second one only contains information about the mine placement (Bomb check in the image).If we oversimplify the bomb check, it basically would boil down to something like a jagged array.if(mines[x][y] == 1) {       GameOver();}If we actually wanted to see if there is a bomb at a certain coordinate, we can simply dereference the following pointer after inserting X and Y accordingly:Minesweeper.exe+ 0xAAA38 ] + 0x18 ] + 0x58 ] + 0x10 ] + 0x8 * x ] + 0x10] + 0x4 * yConclusionI ended up creating a small trainer and a cheat table in the end. Both can be found in the post linked in the Introduction."
  },
  
  {
    "title": "Reverse engineering Task Manager",
    "url": "/posts/task-manager/",
    "categories": "Reverse Engineering",
    "tags": "native, windows, reversing",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionSome time ago I spent some time reversing Task Manager for fun and practice.I will share my findings in this blog post. Note that most of the things in this post might not be interesting and only are here to assist beginners in getting the right mindset for reverse engineering.The Performance TabAt first, I took a look at the Performance tab, because it seemed like an obvious thing to do since I can easily scan for the counter of running processes, threads, and open handles. It was an easy task doing a 4 Byte search for those using Cheat EngineThose 3 values are stored as global variables.CPU Usage GraphAfter that, I was interested in playing around with the CPU usage graphs. I scanned for the current CPU load percentage using the double data type and found one address. Then I looked up what writes to it and jumped to that instruction in IDA.CvSetData is an OpenCV function to set graph data. CvSetDataParemeter is the actual value to be set, it comes right after v39 on the stack, so v39 actually is a struct getting passed in, at least that is my assumption. You can see that the CPU Load value is multiplied by the GraphValueAmplitude. I set a breakpoint there and noticed that its address is static: taskmgr.exe + 0xC0748 + 0x8Its data type is double, the default value is 1. If I set it to 100 all CPU cores will appear as if they were on full load.Manipulating the TimerThe last thing I wanted to manipulate, was the update timer. I did a 4 Bytes scan for an unknown value in CheatEngine. Then changed the update speed in Task Manager and rescanned for increased/decreased values. I quickly found the current delay set by the Timer, but it was read-only. I looked up what writes to it and threw that into IDA.The delay values are hardcoded. Here is the address of the fastest value: taskmgr.exe + 0x33F3AIf you write 20 milliseconds to that address and then choose the “Fast” update speed in Task Manager you will see Task Manager refreshing all values rapidly.ConclusionI hope you gained some knowledge from this post. I also hope I was able to raise your interest in reverse engineering if you are a beginner."
  }
  
]

