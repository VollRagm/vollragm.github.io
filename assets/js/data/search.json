[
  
  {
    "title": "Reverse engineering Task Manager",
    "url": "/posts/TaskManager/",
    "categories": "Reverse Engineering",
    "tags": "native, windows, reversing",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionSome time ago I spent some time reversing Task Manager for fun and practice.I will share my findings in this blog post. Note that most of the things in this post might not be interesting and only are here to assist beginners in getting the right mindset for reverse engineering.The Performance TabAt first, I took a look at the Performance tab, because it seemed like an obvious thing to do since I can easily scan for the counter of running processes, threads, and open handles. It was an easy task doing a 4 Byte search for those using Cheat EngineThose 3 values are stored as global variables.CPU Usage GraphAfter that, I was interested in playing around with the CPU usage graphs. I scanned for the current CPU load percentage using the double data type and found one address. Then I looked up what writes to it and jumped to that instruction in IDA.CvSetData is an OpenCV function to set graph data. CvSetDataParemeter is the actual value to be set, it comes right after v39 on the stack, so v39 actually is a struct getting passed in, at least that is my assumption. You can see that the CPU Load value is multiplied by the GraphValueAmplitude. I set a breakpoint there and noticed that its address is static: taskmgr.exe + 0xC0748 + 0x8Its data type is double, the default value is 1. If I set it to 100 all CPU cores will appear as if they were on full load.Manipulating the TimerThe last thing I wanted to manipulate, was the update timer. I did a 4 Bytes scan for an unknown value in CheatEngine. Then changed the update speed in Task Manager and rescanned for increased/decreased values. I quickly found the current delay set by the Timer, but it was read-only. I looked up what writes to it and threw that into IDA.The delay values are hardcoded. Here is the address of the fastest value: taskmgr.exe + 0x33F3AIf you write 20 milliseconds to that address and then choose the “Fast” update speed in Task Manager you will see Task Manager refreshing all values rapidly.ConclusionI hope you gained some knowledge from this post. I also hope I was able to raise your interest in reverse engineering if you are a beginner."
  },
  
  {
    "title": "PTView - Browse Page Tables on Windows",
    "url": "/posts/PTView/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionPage Tables can be a complicated concept to understand.This is why I created PTView. You can use this tool to visualize page tables and be able to browse them.It allows you to inspect a Windows processes Page Tables live.You can browse through them in a GUI and dump the physical pages they point to, as well as translate virtual to physical addresses and get the virtual address to a PTE.You can get the newest prebuilt release here.UsageYou will have to load the driver before running the client.I recommend loading the Driver normally in test mode, but it can be mapped as well, just make sure the first argument is the driver base and the second argument is NULL.After opening the client, select a process and start browsing its page tables!Key features  Browse Page Tables of Processes, including system processes  Highlight different types of Pages  Dump a physical page  Get the virtual address that leads to the current selection  Translate a physical address to a virtual address with visualization  Get information on a Page table entry  Support for Large PagesThings worth trying out1. Dump the PML4 itself over its auto-entry (self-reference):Every PML4 keeps an entry that has the PML4’s address as PFN itself. This entry is at a fixed index, that Windows nowadays sets randomly during boot.If this entry is selected, the PDPT is the PML4 itself again. If you select it in the PDPT again, the PD also is the PML4 again. If you continue that until the end, the PT will be the PML4, and you will be able to use the PML4 auto-entry to dump the PML4 itself or get its virtual address.Note that this address only is valid in the selected processes context.2. Watch Windows Memory manager map pages, that have been paged out to disk:Get the virtual address of an unused loaded module in the process. Enter it in the Virtual Address textbox and translate it.Chances are that the PTE of that VA or the subsequent PTE’s PFNs is 0x0.Now access the virtual address using a Debugger or Memory viewer, like Cheat Engine, and you will see how it raises a page fault, causing Windows Memory Manager to map the pages live."
  },
  
  {
    "title": "Reverse engineering a Web API",
    "url": "/posts/WebAPI/",
    "categories": "Reverse Engineering",
    "tags": "reversing",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionMost websites or web services have an API in the backend that delivers requested data to its frontend. This can be anything from the Google Search API to delivering a message on Discord.Some people in the gaming community scan a game’s username database for certain available special names, like 3 letter names, to register them. I’ve been asked to write a tool to automate that. To do that I had to reverse engineer the R6DB API. I then could use that API to check for available usernames programmatically.This API has shut down since, likely due to abuse.The method I’m going to show also works on Electron Apps such as Discord by bringing up the DevTools. For any other app, you can use something like Fiddler to intercept the web requests.Finding the correct endpointFirst of all, we will have to find the right endpoint we need to talk to. An endpoint just is a point in a Web API that allows the client to request a specific resource from the server.The website has a textbox which names are typed into. This triggers the browser to send a request to their API. We can simply intercept them by opening the DevTools using Ctrl + Shift + I and then going to the Network tab.You can clear all requests in this window by clicking the clear button next to the red one in the top bar.As you can see, when I typed in a name, Chrome put the requests that were sent to the server into this list. We can now view a request’s information simply by selecting it.The first tab contains the request headers. Those headers provide the information about the request to the server. Stuff like Cookies, Auth Tokens, Cloudflare IDs, and expected response types (JSON, XML, …) get sent here.The URL I have underlined in red is the address this request has been sent to, which also is our target endpoint.As you can see, the syntax seems to be pretty simple: https://api.statsdb.net/r6/namecheck/&amp;lt;username&amp;gt;We can check the response format by clicking on the “Response” tab.The API returns a JSON object. The value “exists” specifies is an account is existent or not.Now that we know the endpoint that receives the requests we can move on to the next step.What else do I need to give the server?Next, you would need to check if the server expects any data from you. As you can see in the header tab, the request type is GET. A GET request does not send any form-data along with it. If it was a POST request, there probably would be data attached to the request in a format like application/form-data or application/json. You can look those up here.So, that means we should be good to go? Let’s try it! I’m gonna try to send a request in an App called Postman which can be used to build custom Web requests and to test Web APIs.I entered the correct URL, selected GET as the request method and the server declined my request and told me I was “Unauthorized”.Let’s take a deeper look into the request that got sent by Chrome…Most of those headers are normal and “don’t really matter”. The only one that immediately gained my attention was the x-api-key. Seems like the Webserver checks if the request was sent from a “real user” using this API Key.  Some APIs also might check if the user-agent is valid.Let’s just try copying out this API key and putting it into our Postman request.Now that I have provided the server with a valid API key it gave me the response I wanted. There is one issue though: This API key I copied keeps changing on each refresh and it also becomes invalid after some time. So, I will have to find a way to generate it myself.  In the image I also added the “origin” header. This was needed for this API to work. I figured this out by adding all headers and then removing them one by one until it stopped working, to see which ones are required.Generating the API-KeyOne thing that’s for sure is that the API Key is getting generated before the request is sent. One way to find out how the API works internally is by clicking on the executing script for the request on the network window and then placing a breakpoint there to check out what the JS code is doing. This can get painful though, especially when the code is obfuscated.I decided to just refresh the page and check out all other requests that we’re made to see if I find the one that contained the API key.I noticed this request to the authscript endpoint. It was a simple GET request and it returned the following plaintext:This is JavaScript code. The eval function executes the function with the parameters that are underlined in red at the bottom. The string at the bottom looks like something that is encrypted in some way and the function decrypts it. I defined both of those functions in the JS Console and then executed them with the provided parameters.The return value surprised me:It returned another JavaScript function as a string. It is called “generateAuthToken”, which looks very promising. It takes a timestamp as input, which I assumed is a simple Unix timestamp.This is what the function looks like after beautifying it:function generateAuthToken(timestamp) {    if (timestamp === undefined) return false;    let seed = &quot;2ef60f0ab98606ec365ac16da6d1e00e3129a5d5&quot;;    let sTimestamp = timestamp + &quot;&quot;;    let code = &quot;&quot;;    for (let i = 0; i &amp;lt; sTimestamp.length; i++) {        let t = parseInt(sTimestamp.charAt(i));        let c = seed.charCodeAt(i % seed.length);        switch (t) {            case 0:                break;            case 1:                c = c - 1;                break;            case 2:                c = c &amp;gt;&amp;gt; 1;                break;            case 3:                c = c &amp;lt;&amp;lt; 1;                break;            case 4:                c = Math.pow(t, c % 4);                break;            case 5:                c = Math.round(Math.sqrt(c));                break;            case 6:                c = c &amp;lt;&amp;lt; t;            case 7:                c = c - 12;                break;            case 8:                c = 0;                break;            default:                c = false;                break;        }        if (c === false) continue;        code += c;    }    return btoa(&quot;authscript:&quot; + code + &quot;:&quot; + timestamp + &quot;:1617148800&quot;);};window.dispatchEvent(new Event(&#39;authscript&#39;));I defined it and called it with the current Unix timestamp.This return value I got looks very much like the API Key that was previously generated by the site itself.I plugged my custom generated API-Key into Postman - et voila!Now we can move on to the next step and use the API in our code.Sending requests to the API programmaticallyI decided to go with C# for my implementation because it has an easy-to-use HttpClient and it’s the language I use the most.If you look into the generateAuthToken function above you will notice that there is this seed that is taken into consideration when decoding the string. A day has passed and I noticed, that this seed changes. That means, that I need to request the source code of the function every time because I cannot hardcode this seed.Luckily, there is a popular library for C# called jint. It’s a basic and relatively lightweight JavaScript interpreter. I simply requested the JS Code from the authscript endpoint and passed it into the JS Engine.Then I passed in the decoded function into it again after some formatting and I could execute it from C# Code.private JsValue ParseAuthTokenGenerator(string encoded, int unknown0, string key, int unknown1, int unknown2, int unknown3){    Engine engine = new Engine();    //those 2 shouldn&#39;t change    engine.Execute(JSCode.CharDecrypter);    engine.Execute(JSCode.StringDecoder);    var jsCode = engine.Invoke(&quot;decodeFunction&quot;, encoded, unknown0, key, unknown1, unknown2, unknown3).AsString()                                                                                .Replace(JSCode.UselessBSCode, &quot;&quot;)                                                                                .Replace(&quot;btoa&quot;, &quot;&quot;) + &quot;}&quot;; // jint has no btoa support    engine.Execute(jsCode);    //return callable generateAuthToken function     return engine.GetValue(&quot;generateAuthToken&quot;);}Both functions that decode the third one don’t change, so I hardcoded them. After decoding generateAuthToken I can simply invoke it and make my request to the API:var apiKey = await GenerateAuthToken();var request = new HttpRequestMessage(HttpMethod.Get, &quot;https://api.statsdb.net/r6/namecheck/&quot; + name);request.Headers.Add(&quot;x-api-key&quot;, APIKey);request.Headers.Add(&quot;origin&quot;, &quot;https://r6db.net&quot;);var response = await httpClient.SendAsync(request);var str = await response.Content.ReadAsStringAsync();ConclusionWhen I was asked to do that, I did not know what exactly this was for. I released this project publicly and based on the number of messages I got after this stopped working, quite a few people were using it.This entire API Key was to prevent spam. One of this websites authors even replied to my original post:  I’m one of the Owners of StatsDB and really cool project you have here but I wanna point something out. We do have a public/developer api and you can get your own key just by signing in and creating a application. No need to reverse enginire our token system it will just work.If a service has a public API available, please use that. However, if there isn’t such a public API or you need to get around an API quota or limit you can always reverse the private API."
  },
  
  {
    "title": "KernelSharp - Write Kernel Drivers in C#",
    "url": "/posts/KernelSharp/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel, .net",
    "date": "2022-04-03 23:00:00 +0200",
    





    "snippet": "IntroductionIn the past, people asked me if it was possible to write a kernel-mode Driver for Windows in C#.Now, you might be thinking that something like this would be totally foolish and serve no purpose.Let me tell you one thing: You are totally right about that.But after getting asked this question multiple times, I have decided to make it possible..NET in Kernel-mode?There are several reasons, why the .NET Runtime is not really able to run in kernel-mode, in fact, there are too many to list them all.The biggest reason, besides its memory management, is the Just-in-time compiler. The runtime compiles the code from MSIL to native code while the program runs. There are a lot of ways in which this could go wrong in kernel mode. As an example, you would never be able to make an HVCI-compatible driver because the native code would have to be written to the heap.However, this is where NativeAOT comes into play.NativeAOTNativeAOT is an experimental fork of the .NET Runtime. At the time of writing it is planned to be moved into mainline development in .NET 7. NativeAOT allows us to compile our C# programs to a native binary ahead of time.It works by taking the intermediate code, transpiling it to native code, and outputting an object file, which can be linked afterward. This compiler is included in the Microsoft.DotNet.ILCompiler package.Follow the NativeAOT quick start guide if you want to create your own project.Developing a DriverIf you want to follow along, feel free to clone the KernelSharp repository, because it basically is ready to compile already.Since we will be going down into kernel mode, we cannot have .NET libraries with us. Simple classes like System.String already require dynamic memory allocation and other routines that are not available in kernel mode in the same way.This is why we have to strip all standard libraries with &amp;lt;NoStdLib&amp;gt;true&amp;lt;/NoStdLib&amp;gt; in the .csproj file. In order to still have the basic datatypes with their basic functionality, we have to define them ourselves. Thankfully this part has been done by Michal Strehovsky for EFI boot applications already. I also recommend enabling unsafe code, because at some point we will be forced to work with pointers.With all of that setup, we can write a simple driver.static uint DriverEntry(){    return 0x0; //STATUS_SUCCESS}However, currently, there is no way to call any kernel-mode API. This part is crucial, otherwise, we would be pretty limited.Normally we would use the DllImport attribute to import native functions from other modules into our C# code, however, that is not available here. We have to use the RuntimeImport attribute, which we once again have to implement it first since all standard libraries have been stripped.After implementing the MethodImpl attribute as well, we can now import functions from ntoskrnl.[MethodImpl(MethodImplOptions.InternalCall)][RuntimeImport(&quot;ntoskrnl.exe&quot;, &quot;ExAllocatePool&quot;)]public static extern PVOID ExAllocatePool(PoolType poolType, ulong size);The code above is from my libraries WDK class. I have imported a lot of useful ntoskrnl functions there and defined some datatypes like PVOID and PEPROCESS.I even implemented __readcr3 using a dirty workaround since the compiler does not support intrinsics yet.public static ulong __readcr3(){    void* buffer = stackalloc byte[0x5C0];    var sat = KeSaveStateForHibernate(buffer); // saves CPU context into buffer    ulong cr3 = *(ulong*)((ulong)buffer + 0x10);    return cr3;}Compiling the DriverThe build script in my repository basically only does 3 simple things:  Compile all C# classes to MSIL  Compile MSIL binary to a native object file using the experimental compiler  Link the object file together with ntoskrnl.lib to a .sys fileLimitationsWhile creating this project, I have come across a few limitations.  No support for variadic argumentsBy default, C# already only supports passing variadic arguments to native functions using the undocumented __arglist. In this case, it seems not to be possible at all, which can make calling functions like DbgPrint a bit annoying, since you can only pass a fixed amount of arguments.  Strings always get stored as Wide-strings by the compilerThis is annoying when you need to pass a normal char* to a function. In those cases you have to convert the string to a char* first.However, Michal Strehovsky pointed out that there is a String Literal Generator for UTF-8 strings on Twitter DMs.  Global strings misplacedI am not entirely sure if this was not an edge case, but when referencing a globally defined string in my code the driver would bugcheck, because the compiler somehow did not place the string at the correct place in memory. I haven’t debugged this any further though and it works when writing the strings inside of the method bodies.ConclusionThis is a very experimental project and I don’t recommend doing this.The only purpose of this project is to prove that kernel drivers are possible in C# and that C# native compilation is around the corner.If you want to see an example of this library being used, check out my KernelBypassSharp repository."
  }
  
]

