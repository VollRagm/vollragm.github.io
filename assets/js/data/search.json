[
  
  {
    "title": "Showing a MessageBox from kernel-mode",
    "url": "/posts/kernel-message-box/",
    "categories": "Kernel Development",
    "tags": "native, kernel, windows, reversing",
    "date": "2022-04-05 14:44:00 +0200",
    





    "snippet": "IntroductionMessage boxes provide a simple way to show feedback to the user. In user-mode, a message box can be shown with the MessageBoxW API function. However, this API does not exist in kernel-mode. One of the common ways to display info from kernel-mode is the DbgPrint API, which can be listened to from DbgView or an attached Kernel debugger. Recently I wanted to display a message box from kernel-mode though, so the user can receive feedback easily. There already are sources on how it’s done out on the web, but I want to take you through the inner workings of the MessageBox function itself and add more information to it.  This entire procedure only works if the calling thread belongs to a user-mode process. This means it works when manually mapping a driver with a mapper like kdmapper. The reason for this limitation will be explained later.MessageBoxWThe MessageBoxW API is located inside of user32.dll. The only thing it does is to call MessageBoxTimeoutW. Inside of MessageBoxTimeoutW, a struct is initialized which holds all arguments for the message box, such as the text, caption, and type. Finally, MessageBoxWorker gets called. This function runs some extra checks, for example, if the current thread is a GUI thread. It also checks whether a parent window handle was passed into MessageBoxW. If that is the case, the function calls into SoftModalMessageBox, otherwise, it calls ServiceMessageBox. Since we don’t have a parent window handle in kernel-mode, we are going to enter ServiceMessageBox.This is where interesting things happen. After checking the threads and processes session IDs it puts the message box arguments into an array and calls the NtRaiseHardError API from ntdll.dll. The ErrorStatus argument is set to 0x50000018, which is STATUS_SERVICE_NOTIFICATION.RtlInitUnicodeString(&amp;amp;lpTextStr, lpText);RtlInitUnicodeString(&amp;amp;lpCaptionStr, lpCaption);arguments[2] = MsgBoxType2;arguments[0] = &amp;amp;lpTextStr;arguments[3] = v4;arguments[1] = &amp;amp;lpCaptionStr;if ( NtRaiseHardError(0x50000018, 4, 3, arguments, 1, &amp;amp;response) &amp;lt; 0 || (v20 = response, response &amp;gt;= 0xB) )    v20 = 1i64;ImplementationWe can reproduce this behavior easily. The kernel-mode API for NtRaiseHardError is the ntoskrnl export ExRaiseHardError.The Response argument even returns the message boxes response, for example, which button the user clicked on a Yes/No prompt. The types match the one from user-mode (e.g. MB_OK, MB_YESNO).As I mentioned above, the calling thread must belong to a user-mode thread. If you use the Service Manager to start your driver and call this in your DriverEntry it will not work. However, if you call it in your IOCTL handler it is going to work because the thread originated from a DeviceIoControl call in a user-mode process. The reason for this limitation is, that ExRaiseHardError in kernel-mode eventually does a Local Procedure Call to the exception port of the executing process. The System process does not have that.Furthermore, the first bit in PEPROCESS-&amp;gt;DefaultHardErrorProcessing has to be set accordingly. I have tried attaching to another process using KeStackAttachProcess, this caused a MessageBox to show up, but it was empty and at this point, I stopped going further.For the people manually mapping their drivers however and wanting simple feedback for a potential user, here is the implementation:extern &quot;C&quot; NTSTATUS NTAPI ExRaiseHardError(    NTSTATUS ErrorStatus, ULONG NumberOfParameters,     ULONG UnicodeStringParameterMask, PULONG_PTR Parameters,    ULONG ValidResponseOptions, PULONG Response);ULONG KeMessageBox(PCWSTR title, PCWSTR text, ULONG_PTR type){    UNICODE_STRING uTitle = { 0 };    UNICODE_STRING uText = { 0 };    RtlInitUnicodeString(&amp;amp;uTitle, title);    RtlInitUnicodeString(&amp;amp;uText, text);    ULONG_PTR args[] = { (ULONG_PTR)&amp;amp;uText, (ULONG_PTR)&amp;amp;uTitle, type };    ULONG response = 0;    ExRaiseHardError(STATUS_SERVICE_NOTIFICATION, 3, 3, args, 2, &amp;amp;response);    return response;}Usage example:#define MB_OK 0x00000000LULONG result = KeMessageBox(L&quot;Hello world!&quot;, L&quot;Greetings from kernel-mode&quot;, MB_OK);This is the enum containing all possible results:typedef enum _HARDERROR_RESPONSE{    ResponseReturnToCaller,    ResponseNotHandled,    ResponseAbort,    ResponseCancel,    ResponseIgnore,    ResponseNo,    ResponseOk,    ResponseRetry,    ResponseYes,    ResponseTryAgain,    ResponseContinue} HARDERROR_RESPONSE;"
  },
  
  {
    "title": "Unity Engine reversing and hacking",
    "url": "/posts/unity-reversing/",
    "categories": "Reverse Engineering",
    "tags": ".net, reversing, game hacking",
    "date": "2022-04-04 23:41:00 +0200",
    





    "snippet": "IntroductionUnity3D is a popular game engine used by many games, like Escape from Tarkov, Rust, Fall Guys, Among Us, and many more. The engine uses C# as scripting backend, and by default runs on top of the Mono Runtime. Since C# assemblies get compiled to MSIL, we can easily reverse engineer them using tools like dnSpy.We are also able to easily inject our dependencies and even reference the games and the engine’s dependencies in our source code. In Unity, this generally is used for writing mods, such as for the game Beat Saber, which depends on the modding community.In this post I will be using the simple game Adventure Communist, which is for free on steam.  Show screenshot of the game      This game is not protected by Il2Cpp. Games like Fall Guys and Among Us are. However, you can achieve the same results by using tools like Il2CppDumper and Il2CppAssemblyUnhollower.Decompiling the game’s codeAll (non-il2cpp) Unity games have an Assembly-CSharp.dll located inside of GameRoot\\TheNameOfTheGame_Data\\Managed\\. This file contains all game scripts. We need to plug this DLL into a .NET decompiler. I recommend dnSpy because it is very powerful.Finding a starting pointThis game is a clicker game and its goal is to gain as many resources as possible. Let’s try to increase the number of potatoes.Obviously, one could simply edit the save files, however, that would be very boring.I started by using the search tool in dnSpy to search for Potato. The search tool can be found in the top bar, right next to the Start button. The search yielded a single result.It’s an Enum with all types of resources that can be gathered in the game.Now, if you have some experience with IDA, the next thing you would do here is to look for cross-references. We are going to do the same thing here.Going down the rabbit holeLet’s see what references that Enum. We have to find the class that contains all values we need.We can list cross-references in dnSpy by right-clicking the Enums name and then clicking Analyze. A list is going to show up listing all types of usages of the Enum. I noticed that the Enum was being used in a class called GeneratorData.The game has different types of “Generators” which generate items while you aren’t clicking. Now we do the same trick on the GeneratorData class: right-click -&amp;gt; Analyze.dnSpy will show us, that a GeneretorData object is being used to initialize an object of type GeneratorModel inside of the Execute method in the InitializeGameModelCommand class.This method seems to be initializing Generators for all kinds of resources.An object of type GameModel is passed into this method which contains a Dictionary called Resources. This is the Dictionary that stores the number of resources we have.This means that we have to get this GameModel instance somehow. However, before that, we are going to take a quick dive into the engine’s principles.What is a GameObject?We know that we have to find the GameModel instance. To do so, we have to understand the engine’s structure first.Every scene holds GameObjects. GameObjects do nothing by default. However, we can apply components to a GameObject, such as a C# script.All C# script classes have to inherit from the MonoBehaviour class.After doing so, you can place methods like Start() or Update() in your code and the engine will call them for you at initialization or on each frame.This means that we can assume, that the game has a GameObject somewhere which has a script component managing the game. This script class likely holds the GameModel instance we are searching for.Finding the game managerWe know, that the GameModel is getting initialized by that Execute method. This method call can once again be traced using dnSpy’s Analyze feature.The method is getting called from GameController.Init().This GameController class however still does not inherit MonoBehaviour, which means that it is not a component of a GameObject.We need to repeat the analysis on the GameController class to see, where it’s being initialized.We end up in SceneRootGame.Start().SceneRootGame does inherit from MonoBehaviour and it also has the Start() method, which will get called by the engine when the GameObject spawns.It also holds a reference to the GameController, which holds the reference to the GameModel. Finally, the GameModel has the dictionary with all resource counts.Developing a hack trainerThe gained knowledge can be used to write a DLL dependency that can be injected into the game. For this, you are going to need to set up a C# class library, reference the game’s DLLs, and set up a loader. If you haven’t done this before I highly recommend you to check out Zat’s Beginner’s Guide To Hacking Unity Games because the entire set up procedure is explained there.Anyways, the final step is getting the SceneRootGame instance itself. Since it is a GameObject component, we can use the engine method GameObject.FindObjectOfType&amp;lt;Type&amp;gt;() to search for the instance.If we pass in SceneRootGame as the type, we will get the first SceneRootGame instance it finds. Once again, this then contains the GameModel, et cetera.The following code is going to give us a lot of potatoes.using AdComm; //import game namespaceusing System;using System.Collections.Generic;using System.Linq;using UnityEngine;  //import unity engine namespace public class ItemsCheat{    public void CheatPotatoes()    {        SceneRootGame sceneRoot = GameObject.FindObjectOfType&amp;lt;SceneRootGame&amp;gt;(); //get the SceneRootGame object that controls everything        GameController gameController = sceneRoot.Game; //get the GameController of the SceneRootGame        GameModel gameModel = gameController.Model; //get the game model         gameModel.Resources[ AdComm.Resources.Resource.Potato ].Value = 10000000;   //set the value of the Potato Resource to a high number    }}We can iterate over the resources Enum and set all types of resources to a high value as well.public void GetAllItems(){    SceneRootGame sceneRoot = GameObject.FindObjectOfType&amp;lt;SceneRootGame&amp;gt;(); //get the SceneRootGame object that controls everything    GameController gameController = sceneRoot.Game; //get the GameController of the SceneRootGame    GameModel gameModel = gameController.Model; //get the game model    List&amp;lt;AdComm.Resources.Resource&amp;gt; AllResources = Enum.GetValues(                                                    typeof(AdComm.Resources.Resource))                                                    .Cast&amp;lt;AdComm.Resources.Resource&amp;gt;().ToList();  //get all available Resource Types as list    foreach (AdComm.Resources.Resource resourceType in AllResources) //iterate through the resources    {        gameModel.Resources[resourceType].Value = 1000000000; //set amount of the resource to huge number    }}ConclusionUnity game hacking is a lot of fun. There is a lot that can be done thanks to the direct access to engine methods.You can easily spawn new GameObjects, modify textures, and do a lot of other things. It gets slightly harder when the game is protected with Il2cpp, but not impossible. Sadly many multiplayer games use advanced anti-cheats like EasyAntiCheat, and due to the nature of Mono injection, it is hard to inject a Mono DLL without getting caught by the anti-cheat. In those cases, it’s probably better to go for a native approach."
  },
  
  {
    "title": "Reverse Engineering Windows 7 Minesweeper",
    "url": "/posts/minesweeper/",
    "categories": "Reverse Engineering",
    "tags": "native, windows, reversing, game hacking",
    "date": "2022-04-04 22:23:00 +0200",
    





    "snippet": "IntroductionThis blog post is about how to approach reverse engineering using the Windows 7 version of Minesweeper as an example. You can get the Windows 7 Minesweeper from https://win7games.com/.I have created a trainer and a CheatEngine cheat table as well. You can find it here.This post is written for beginners, however, I recommend having the following already:  Basic understanding of Pointers  Basic understanding of the C/C++ language  Good understanding of Cheat Engine  A little bit of ASM knowledge  Native Decompiler (IDA, Ghidra, …)  PatienceFinding a starting pointWhenever you want to reverse engineer something, you need a starting point. This could be anything from an interesting instruction to a global variable. CheatEngine is a tool that is very helpful to find such variables. For example, in a First-person-shooter game, I would start scanning for values like the health or bullet count, however, in Minesweeper I decided to scan for the timer value.The timer value is on the bottom leftAs you can see the Timer value is 6 in this image. So I started to scan for a 4-byte value.I did not get a single result. Then I tried a different datatype: float.The right address popped up in the first scan. When I changed it, the timer in the game changed as well, so I know it was the right one.Now we have found the value of the timer.Tinkering around with the TimerOf course, we can now set the timer value to anything we want. But what else can we do? By right-clicking the address in Cheat Engine and then clicking Find out what writes to this address we can determine the instruction, that is writing to the address.We can select the instruction and show it in the disassembler. This takes us directly to the part in the code responsible for updating the timer.We can see that the instruction adding to the timer value is addss xmm0,[7FF7812E4454] , which means if we patch that to subss xmm0,[7FF7812E4454] (add stands for add, sub stands for subtract), then we will see the timer running backward.Finding more valuesIn the instruction from the previous headline we could see that the address of the timer value is at rax + 0x20. We can assume that rax is a pointer to some kind of structure containing other useful variables. To check that we right-click the address and hit Browse this memory region in CheatEngine. Now the bottom part of the memory viewer will show the neighboring addresses. Click inside that window and hit Ctrl + 6 to change the datatype to 4 bytes. Scroll up a bit to be able to see the values that come right before the timer.The value highlighted in red is the timer value.It’s being displayed wrongly because we set the datatype to 4 bytes instead of float. However, it is surrounded by other values. Now you need to look at which addresses change when you do something. I’ve already done that.The first address, which is at offset 0x8 from the beginning of the structure is the number of bombs. It is followed by FieldSizeY, FieldSizeX. The next 0 is the number of flags, the 6 is the number of revealed fields, and the 1 is how many times you have clicked. The 1 right next to the timer is the difficulty level.To find a Pointer for that struct, you can run a pointer scan or manually reverse it. I manually reversed it: Minesweeper.exe+ 0xAAA38 ] + 0x18 ].If you dereference this pointer and add 0x20 to it, you will get the address of the timer (think of the rax + 0x20 from earlier).Finding the bomb arrayI figured out that a good approach to finding the bomb array is to find the function that is called whenever I click a field.Do you remember the value that counts how many times you click?This pointer points to it: Minesweeper.exe+ 0xAAA38 ] + 0x18 ] + 0x1C.It must be associated with the function we are searching for in some way, so let’s do the trick again: right-click the address -&amp;gt; Find out what writes to this address. Now you need to click a field in Minesweeper. You will see an instruction popping up in CheatEngine: inc [rbx+1C]. This instruction increases [rbx + 0x1C] by one. RBX contains the address of that same structure from earlier again here. I will be calling it GameManager from now on.Now, this is where our Decompiler comes into play. I’m going to use IDA.Load Minesweeper.exe into the decompiler, let the analysis finish, and rebase the image. In IDA you can do this by going to Edit -&amp;gt; Segments -&amp;gt; Rebase program. Enter the module base address of Minesweeper in there, which you can get from CheatEngine.After that is done, jump to the instruction address that increased the click count in IDA.In IDA you can hit F5 to decompile it to pseudo-C-code.I recommend converting the pointer offsets from decimal to hexadecimal by clicking them and hitting H on the keyboard.First of all, the ++v6[7] in line 22 is the instruction that increased the counter.Now I analyzed the parameters that have been passed into the function by setting a breakpoint at the start of the function in CheatEngine. I clicked another field to trigger the breakpoint.The first parameter is the GameManager from earlier, the second parameter was the X coordinate I clicked, and the third one is the Y coordinate. I renamed them accordingly in IDA.Now I saw those two big if statements, both using the X and Y variable. After looking up, what their values are, I found out, that they are two different data structures. One of them contains the state of the field (for example if it has been revealed already), and the second one only contains information about the mine placement (Bomb check in the image).If we oversimplify the bomb check, it basically would boil down to something like a jagged array.if(mines[x][y] == 1) {       GameOver();}If we actually wanted to see if there is a bomb at a certain coordinate, we can simply dereference the following pointer after inserting X and Y accordingly:Minesweeper.exe+ 0xAAA38 ] + 0x18 ] + 0x58 ] + 0x10 ] + 0x8 * x ] + 0x10] + 0x4 * yConclusionI ended up creating a small trainer and a cheat table in the end. Both can be found in the post linked in the Introduction."
  },
  
  {
    "title": "Reverse engineering a Web API",
    "url": "/posts/web-api/",
    "categories": "Reverse Engineering",
    "tags": "reversing",
    "date": "2022-04-04 01:34:00 +0200",
    





    "snippet": "IntroductionMost websites or web services have an API in the backend that delivers requested data to its frontend. This can be anything from the Google Search API to delivering a message on Discord.Some people in the gaming community scan a game’s username database for certain available special names, like 3 letter names, to register them. I’ve been asked to write a tool to automate that. To do that I had to reverse engineer the R6DB API. I then could use that API to check for available usernames programmatically.This API has shut down since, likely due to abuse.The method I’m going to show also works on Electron Apps such as Discord by bringing up the DevTools. For any other app, you can use something like Fiddler to intercept the web requests.Finding the correct endpointFirst of all, we will have to find the right endpoint we need to talk to. An endpoint just is a point in a Web API that allows the client to request a specific resource from the server.The website has a textbox which names are typed into. This triggers the browser to send a request to their API. We can simply intercept them by opening the DevTools using Ctrl + Shift + I and then going to the Network tab.You can clear all requests in this window by clicking the clear button next to the red one in the top bar.As you can see, when I typed in a name, Chrome put the requests that were sent to the server into this list. We can now view a request’s information simply by selecting it.The first tab contains the request headers. Those headers provide the information about the request to the server. Stuff like Cookies, Auth Tokens, Cloudflare IDs, and expected response types (JSON, XML, …) get sent here.The URL I have underlined in red is the address this request has been sent to, which also is our target endpoint.As you can see, the syntax seems to be pretty simple: https://api.statsdb.net/r6/namecheck/&amp;lt;username&amp;gt;We can check the response format by clicking on the “Response” tab.The API returns a JSON object. The value “exists” specifies is an account is existent or not.Now that we know the endpoint that receives the requests we can move on to the next step.What else do I need to give the server?Next, you would need to check if the server expects any data from you. As you can see in the header tab, the request type is GET. A GET request does not send any form-data along with it. If it was a POST request, there probably would be data attached to the request in a format like application/form-data or application/json. You can look those up here.So, that means we should be good to go? Let’s try it! I’m gonna try to send a request in an App called Postman which can be used to build custom Web requests and to test Web APIs.I entered the correct URL, selected GET as the request method and the server declined my request and told me I was “Unauthorized”.Let’s take a deeper look into the request that got sent by Chrome…Most of those headers are normal and “don’t really matter”. The only one that immediately gained my attention was the x-api-key. Seems like the Webserver checks if the request was sent from a “real user” using this API Key.  Some APIs also might check if the user-agent is valid.Let’s just try copying out this API key and putting it into our Postman request.Now that I have provided the server with a valid API key it gave me the response I wanted. There is one issue though: This API key I copied keeps changing on each refresh and it also becomes invalid after some time. So, I will have to find a way to generate it myself.  In the image I also added the “origin” header. This was needed for this API to work. I figured this out by adding all headers and then removing them one by one until it stopped working, to see which ones are required.Generating the API-KeyOne thing that’s for sure is that the API Key is getting generated before the request is sent. One way to find out how the API works internally is by clicking on the executing script for the request on the network window and then placing a breakpoint there to check out what the JS code is doing. This can get painful though, especially when the code is obfuscated.I decided to just refresh the page and check out all other requests that we’re made to see if I find the one that contained the API key.I noticed this request to the authscript endpoint. It was a simple GET request and it returned the following plaintext:This is JavaScript code. The eval function executes the function with the parameters that are underlined in red at the bottom. The string at the bottom looks like something that is encrypted in some way and the function decrypts it. I defined both of those functions in the JS Console and then executed them with the provided parameters.The return value surprised me:It returned another JavaScript function as a string. It is called “generateAuthToken”, which looks very promising. It takes a timestamp as input, which I assumed is a simple Unix timestamp.This is what the function looks like after beautifying it:function generateAuthToken(timestamp) {    if (timestamp === undefined) return false;    let seed = &quot;2ef60f0ab98606ec365ac16da6d1e00e3129a5d5&quot;;    let sTimestamp = timestamp + &quot;&quot;;    let code = &quot;&quot;;    for (let i = 0; i &amp;lt; sTimestamp.length; i++) {        let t = parseInt(sTimestamp.charAt(i));        let c = seed.charCodeAt(i % seed.length);        switch (t) {            case 0:                break;            case 1:                c = c - 1;                break;            case 2:                c = c &amp;gt;&amp;gt; 1;                break;            case 3:                c = c &amp;lt;&amp;lt; 1;                break;            case 4:                c = Math.pow(t, c % 4);                break;            case 5:                c = Math.round(Math.sqrt(c));                break;            case 6:                c = c &amp;lt;&amp;lt; t;            case 7:                c = c - 12;                break;            case 8:                c = 0;                break;            default:                c = false;                break;        }        if (c === false) continue;        code += c;    }    return btoa(&quot;authscript:&quot; + code + &quot;:&quot; + timestamp + &quot;:1617148800&quot;);};window.dispatchEvent(new Event(&#39;authscript&#39;));I defined it and called it with the current Unix timestamp.This return value I got looks very much like the API Key that was previously generated by the site itself.I plugged my custom generated API-Key into Postman - et voila!Now we can move on to the next step and use the API in our code.Sending requests to the API programmaticallyI decided to go with C# for my implementation because it has an easy-to-use HttpClient and it’s the language I use the most.If you look into the generateAuthToken function above you will notice that there is this seed that is taken into consideration when decoding the string. A day has passed and I noticed, that this seed changes. That means, that I need to request the source code of the function every time because I cannot hardcode this seed.Luckily, there is a popular library for C# called jint. It’s a basic and relatively lightweight JavaScript interpreter. I simply requested the JS Code from the authscript endpoint and passed it into the JS Engine.Then I passed in the decoded function into it again after some formatting and I could execute it from C# Code.private JsValue ParseAuthTokenGenerator(string encoded, int unknown0, string key, int unknown1, int unknown2, int unknown3){    Engine engine = new Engine();    //those 2 shouldn&#39;t change    engine.Execute(JSCode.CharDecrypter);    engine.Execute(JSCode.StringDecoder);    var jsCode = engine.Invoke(&quot;decodeFunction&quot;, encoded, unknown0, key, unknown1, unknown2, unknown3).AsString()                                                                                .Replace(JSCode.UselessBSCode, &quot;&quot;)                                                                                .Replace(&quot;btoa&quot;, &quot;&quot;) + &quot;}&quot;; // jint has no btoa support    engine.Execute(jsCode);    //return callable generateAuthToken function     return engine.GetValue(&quot;generateAuthToken&quot;);}Both functions that decode the third one don’t change, so I hardcoded them. After decoding generateAuthToken I can simply invoke it and make my request to the API:var apiKey = await GenerateAuthToken();var request = new HttpRequestMessage(HttpMethod.Get, &quot;https://api.statsdb.net/r6/namecheck/&quot; + name);request.Headers.Add(&quot;x-api-key&quot;, APIKey);request.Headers.Add(&quot;origin&quot;, &quot;https://r6db.net&quot;);var response = await httpClient.SendAsync(request);var str = await response.Content.ReadAsStringAsync();ConclusionWhen I was asked to do that, I did not know what exactly this was for. I released this project publicly and based on the number of messages I got after this stopped working, quite a few people were using it.This entire API Key was to prevent spam. One of this websites authors even replied to my original post:  I’m one of the Owners of StatsDB and really cool project you have here but I wanna point something out. We do have a public/developer api and you can get your own key just by signing in and creating a application. No need to reverse enginire our token system it will just work.If a service has a public API available, please use that. However, if there isn’t such a public API or you need to get around an API quota or limit you can always reverse the private API."
  },
  
  {
    "title": "Reverse engineering Task Manager",
    "url": "/posts/task-manager/",
    "categories": "Reverse Engineering",
    "tags": "native, windows, reversing",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionSome time ago I spent some time reversing Task Manager for fun and practice.I will share my findings in this blog post. Note that most of the things in this post might not be interesting and only are here to assist beginners in getting the right mindset for reverse engineering.The Performance TabAt first, I took a look at the Performance tab, because it seemed like an obvious thing to do since I can easily scan for the counter of running processes, threads, and open handles. It was an easy task doing a 4 Byte search for those using Cheat EngineThose 3 values are stored as global variables.CPU Usage GraphAfter that, I was interested in playing around with the CPU usage graphs. I scanned for the current CPU load percentage using the double data type and found one address. Then I looked up what writes to it and jumped to that instruction in IDA.CvSetData is an OpenCV function to set graph data. CvSetDataParemeter is the actual value to be set, it comes right after v39 on the stack, so v39 actually is a struct getting passed in, at least that is my assumption. You can see that the CPU Load value is multiplied by the GraphValueAmplitude. I set a breakpoint there and noticed that its address is static: taskmgr.exe + 0xC0748 + 0x8Its data type is double, the default value is 1. If I set it to 100 all CPU cores will appear as if they were on full load.Manipulating the TimerThe last thing I wanted to manipulate, was the update timer. I did a 4 Bytes scan for an unknown value in CheatEngine. Then changed the update speed in Task Manager and rescanned for increased/decreased values. I quickly found the current delay set by the Timer, but it was read-only. I looked up what writes to it and threw that into IDA.The delay values are hardcoded. Here is the address of the fastest value: taskmgr.exe + 0x33F3AIf you write 20 milliseconds to that address and then choose the “Fast” update speed in Task Manager you will see Task Manager refreshing all values rapidly.ConclusionI hope you gained some knowledge from this post. I also hope I was able to raise your interest in reverse engineering if you are a beginner."
  },
  
  {
    "title": "PTView - Browse Page Tables on Windows",
    "url": "/posts/ptview/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel",
    "date": "2022-04-04 00:39:00 +0200",
    





    "snippet": "IntroductionPage Tables can be a complicated concept to understand.This is why I created PTView. You can use this tool to visualize page tables and be able to browse them.It allows you to inspect a Windows processes Page Tables live.You can browse through them in a GUI and dump the physical pages they point to, as well as translate virtual to physical addresses and get the virtual address to a PTE.You can get the newest prebuilt release here.UsageYou will have to load the driver before running the client.I recommend loading the Driver normally in test mode, but it can be mapped as well, just make sure the first argument is the driver base and the second argument is NULL.After opening the client, select a process and start browsing its page tables!Key features  Browse Page Tables of Processes, including system processes  Highlight different types of Pages  Dump a physical page  Get the virtual address that leads to the current selection  Translate a physical address to a virtual address with visualization  Get information on a Page table entry  Support for Large PagesThings worth trying out1. Dump the PML4 itself over its auto-entry (self-reference):Every PML4 keeps an entry that has the PML4’s address as PFN itself. This entry is at a fixed index, that Windows nowadays sets randomly during boot.If this entry is selected, the PDPT is the PML4 itself again. If you select it in the PDPT again, the PD also is the PML4 again. If you continue that until the end, the PT will be the PML4, and you will be able to use the PML4 auto-entry to dump the PML4 itself or get its virtual address.Note that this address only is valid in the selected processes context.2. Watch Windows Memory manager map pages, that have been paged out to disk:Get the virtual address of an unused loaded module in the process. Enter it in the Virtual Address textbox and translate it.Chances are that the PTE of that VA or the subsequent PTE’s PFNs is 0x0.Now access the virtual address using a Debugger or Memory viewer, like Cheat Engine, and you will see how it raises a page fault, causing Windows Memory Manager to map the pages live."
  },
  
  {
    "title": "KernelSharp - Write Kernel Drivers in C#",
    "url": "/posts/kernelsharp/",
    "categories": "Kernel Development",
    "tags": "native, windows, kernel, .net",
    "date": "2022-04-03 23:00:00 +0200",
    





    "snippet": "IntroductionIn the past, people asked me if it was possible to write a kernel-mode Driver for Windows in C#.Now, you might be thinking that something like this would be totally foolish and serve no purpose.Let me tell you one thing: You are totally right about that.But after getting asked this question multiple times, I have decided to make it possible..NET in Kernel-mode?There are several reasons, why the .NET Runtime is not really able to run in kernel-mode, in fact, there are too many to list them all.The biggest reason, besides its memory management, is the Just-in-time compiler. The runtime compiles the code from MSIL to native code while the program runs. There are a lot of ways in which this could go wrong in kernel mode. As an example, you would never be able to make an HVCI-compatible driver because the native code would have to be written to the heap.However, this is where NativeAOT comes into play.NativeAOTNativeAOT is an experimental fork of the .NET Runtime. At the time of writing it is planned to be moved into mainline development in .NET 7. NativeAOT allows us to compile our C# programs to a native binary ahead of time.It works by taking the intermediate code, transpiling it to native code, and outputting an object file, which can be linked afterward. This compiler is included in the Microsoft.DotNet.ILCompiler package.Follow the NativeAOT quick start guide if you want to create your own project.Developing a DriverIf you want to follow along, feel free to clone the KernelSharp repository, because it basically is ready to compile already.Since we will be going down into kernel mode, we cannot have .NET libraries with us. Simple classes like System.String already require dynamic memory allocation and other routines that are not available in kernel mode in the same way.This is why we have to strip all standard libraries with &amp;lt;NoStdLib&amp;gt;true&amp;lt;/NoStdLib&amp;gt; in the .csproj file. In order to still have the basic datatypes with their basic functionality, we have to define them ourselves. Thankfully this part has been done by Michal Strehovsky for EFI boot applications already. I also recommend enabling unsafe code, because at some point we will be forced to work with pointers.With all of that setup, we can write a simple driver.static uint DriverEntry(){    return 0x0; //STATUS_SUCCESS}However, currently, there is no way to call any kernel-mode API. This part is crucial, otherwise, we would be pretty limited.Normally we would use the DllImport attribute to import native functions from other modules into our C# code, however, that is not available here. We have to use the RuntimeImport attribute, which we once again have to implement it first since all standard libraries have been stripped.After implementing the MethodImpl attribute as well, we can now import functions from ntoskrnl.[MethodImpl(MethodImplOptions.InternalCall)][RuntimeImport(&quot;ntoskrnl.exe&quot;, &quot;ExAllocatePool&quot;)]public static extern PVOID ExAllocatePool(PoolType poolType, ulong size);The code above is from my libraries WDK class. I have imported a lot of useful ntoskrnl functions there and defined some datatypes like PVOID and PEPROCESS.I even implemented __readcr3 using a dirty workaround since the compiler does not support intrinsics yet.public static ulong __readcr3(){    void* buffer = stackalloc byte[0x5C0];    var sat = KeSaveStateForHibernate(buffer); // saves CPU context into buffer    ulong cr3 = *(ulong*)((ulong)buffer + 0x10);    return cr3;}Compiling the DriverThe build script in my repository basically only does 3 simple things:  Compile all C# classes to MSIL  Compile MSIL binary to a native object file using the experimental compiler  Link the object file together with ntoskrnl.lib to a .sys fileLimitationsWhile creating this project, I have come across a few limitations.  No support for variadic argumentsBy default, C# already only supports passing variadic arguments to native functions using the undocumented __arglist. In this case, it seems not to be possible at all, which can make calling functions like DbgPrint a bit annoying, since you can only pass a fixed amount of arguments.  Strings always get stored as Wide-strings by the compilerThis is annoying when you need to pass a normal char* to a function. In those cases you have to convert the string to a char* first.However, Michal Strehovsky pointed out that there is a String Literal Generator for UTF-8 strings on Twitter DMs.  Global strings misplacedI am not entirely sure if this was not an edge case, but when referencing a globally defined string in my code the driver would bugcheck, because the compiler somehow did not place the string at the correct place in memory. I haven’t debugged this any further though and it works when writing the strings inside of the method bodies.ConclusionThis is a very experimental project and I don’t recommend doing this.The only purpose of this project is to prove that kernel drivers are possible in C# and that C# native compilation is around the corner.If you want to see an example of this library being used, check out my KernelBypassSharp repository."
  }
  
]

